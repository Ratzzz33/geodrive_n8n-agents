# Полное руководство по работе с RentProg API и Webhooks

Этот документ содержит весь накопленный опыт интеграции с RentProg API и обработки вебхуков. Предназначен для использования в других проектах для быстрого старта без прохождения всего пути заново.

## Содержание

1. [Аутентификация](#аутентификация)
2. [API Endpoints](#api-endpoints)
3. [Rate Limiting и Задержки](#rate-limiting-и-задержки)
4. [Webhooks](#webhooks)
5. [Форматы данных](#форматы-данных)
6. [Обработка ошибок](#обработка-ошибок)
7. [Лучшие практики](#лучшие-практики)

---

## Аутентификация

### Двухэтапная аутентификация

RentProg использует двухэтапную систему аутентификации:

1. **Company Token** — постоянный ключ компании (хранится в секретах)
2. **Request Token** — временный токен для API запросов (TTL ~4 минуты)

### Получение Request Token

```http
GET /get_token?company_token={company_token}
```

**Ответ:**
```json
{
  "token": "eyJhbGciOiJIUzI1NiJ9...",
  "exp": "2025-09-30T23:33:37.000+00:00"
}
```

### Использование токена в запросах

Все последующие API запросы требуют заголовок:
```
Authorization: Bearer {request_token}
```

### Кэширование токенов

**Важно:** Request tokens имеют TTL ~240 секунд (4 минуты). Кэшируйте их:
- В памяти (in-memory cache с TTL)
- В БД (опционально, для распределённых систем)

**Стратегия кэширования:**
- Проверять истечение токена с запасом 2 секунды (чтобы не получить 401 во время запроса)
- При истечении — автоматически обновлять через `/get_token`

### Конфигурация аутентификации

Переменные окружения для настройки аутентификации:

- `RENTPROG_BASE_URL` — базовый URL API (по умолчанию: `https://rentprog.net/api/v1/public`)
- `RENTPROG_AUTH_URL` — endpoint для получения токена (по умолчанию: `/get_token`)
- `RENTPROG_AUTH_METHOD` — HTTP метод (`GET` или `POST`, по умолчанию: `GET`)
- `RENTPROG_AUTH_STYLE` — способ передачи токена (`query`, `header`, `body`, по умолчанию: `query`)
- `RENTPROG_AUTH_HEADER` — имя заголовка для токена (если `style=header`, по умолчанию: `Authorization`)
- `RENTPROG_AUTH_BODY_KEY` — ключ в body для токена (если `style=body`, по умолчанию: `company_token`)
- `RENTPROG_REQUEST_TOKEN_TTL_SEC` — TTL токена в секундах (по умолчанию: `240`)

---

## API Endpoints

### Автомобили (Cars)

#### 1. Список всех автомобилей (краткий)

```http
GET /all_cars
```

**Ответ:**
```json
[
  {
    "id": 45373,
    "car_name": "Toyota Camry",
    "year": 2020,
    "transmission": "Автоматическая"
  }
]
```

#### 2. Список всех автомобилей (полный)

```http
GET /all_cars_full
```

**Ответ:** См. [Форматы данных - Автомобили](#автомобили)

#### 3. Информация об автомобиле

```http
GET /cars/{id}
# или
GET /car/{id}
```

**Fallback:** Если `/cars/{id}` возвращает 404, пробуйте `/car/{id}`

#### 4. Расширенная информация с бронированиями

```http
GET /car_data_with_bookings?car_id={id}
```

**Содержит:**
- Основная информация об автомобиле
- Активные бронирования
- Цены и периоды
- Сезоны
- Ограничения (часы, депозит)

#### 5. Поиск автомобилей

```http
GET /search_cars?query={search_term}&page=1&per_page=10
```

#### 6. Свободные автомобили

```http
GET /free_cars?start_date={DD-MM-YYYY H:mm}&end_date={DD-MM-YYYY H:mm}
```

**Формат даты:** `DD-MM-YYYY H:mm` (например: `25-01-2022 10:00`)

### Клиенты (Clients)

#### 1. Список клиентов

```http
GET /clients?page=1&per_page=10
# или (fallback)
GET /all_clients?page=1&per_page=10
```

#### 2. Информация о клиенте

```http
GET /clients/{id}
# или (fallback)
GET /client/{id}
```

#### 3. Поиск клиентов

```http
GET /search_clients?query={search_term}
```

### Бронирования (Bookings)

#### 1. Активные бронирования

```http
GET /active_bookings?page=1&per_page=10
```

#### 2. Неактивные бронирования

```http
GET /unactive_bookings?page=1&per_page=10
```

#### 3. Все бронирования

```http
GET /all_bookings?page=1&per_page=10
```

**Важно:** Возвращает активные + неактивные, исключая архивные.

#### 4. Информация о бронировании

```http
GET /bookings/{id}
# или (fallback)
GET /booking/{id}
# или (fallback)
GET /booking?id={id}
```

**Стратегия:** Пробуйте варианты последовательно, если один возвращает 404.

#### 5. Поиск бронирований

```http
GET /search_bookings?query={search_term}
```

---

## Rate Limiting и Задержки

### Rate Limiting для API запросов

RentProg имеет внутренние лимиты. Рекомендуется использовать собственные лимитеры:

**Рекомендуемые лимиты:**
- **Read операции** (GET): 60 запросов в минуту
- **Write операции** (POST/PUT/DELETE): 30 запросов в минуту
- **Search операции**: 15 запросов в минуту
- **Auth операции** (получение токенов): 30 запросов в минуту

**Реализация:**
- Используйте token bucket или sliding window
- Разделяйте лимитеры по типу операции
- Не превышайте лимиты — это может привести к временной блокировке

### Таймауты и Retry

**Конфигурация:**
- `RENTPROG_REQUEST_TIMEOUT_MS` — таймаут одного запроса (по умолчанию: `15000` мс = 15 секунд)
- `RENTPROG_RETRY_MAX_ATTEMPTS` — максимум попыток (по умолчанию: `3`)
- `RENTPROG_RETRY_BASE_DELAY_MS` — базовая задержка между попытками (по умолчанию: `250` мс)
- `RENTPROG_RETRY_JITTER_MS` — случайная вариация задержки (по умолчанию: `100` мс)

**Стратегия Retry:**
1. Повторять только при сетевых ошибках и 5xx статусах
2. Не повторять при 4xx (кроме 429 Rate Limit)
3. Использовать экспоненциальный backoff: `delay = base * 2^(attempt-1) + jitter`
4. После каждого retry увеличивать задержку

**Пример:**
- Попытка 1: сразу
- Попытка 2: через ~250-350 мс
- Попытка 3: через ~500-600 мс

### Обработка 429 (Rate Limit)

При получении 429:
1. **Немедленно остановить запросы** по этому типу операции
2. **Подождать** согласно `Retry-After` заголовку (если есть)
3. **Или использовать фиксированную задержку** (например, 60 секунд)
4. **Логировать** для мониторинга превышения лимитов

### Задержки в производстве

**Типичные задержки:**
- Простые GET запросы: 200-800 мс
- Запросы с большим объёмом данных: 1-3 секунды
- Поиск: 500 мс - 2 секунды
- Получение токена: 100-400 мс

**Оптимизация:**
- Кэшируйте токены (экономия 100-400 мс на запрос)
- Используйте параллельные запросы где возможно
- Батчируйте операции при массовой обработке

---

## Webhooks

### Endpoint для вебхуков

RentProg отправляет события на настроенный URL:

```
POST {your_webhook_url}
```

**Рекомендуемый формат URL:**
```
POST /api/rentprog/webhook
```

### Обработка входящих вебхуков

#### 1. Rate Limiting для вебхуков

**Важно:** Защитите endpoint от перегрузки:

- Лимит: **30 запросов в секунду** на IP адрес
- Окно: **60 секунд**
- При превышении: возвращать `429 Too Many Requests` с `retry_after: 60`

#### 2. Ограничение размера JSON

- Максимальный размер JSON payload: **256 КБ**
- При превышении: возвращать `413 Payload Too Large`

#### 3. Быстрый ACK (Acknowledgment)

**Правило:** Всегда отвечайте быстро (≤ 100 мс):

1. Принять запрос
2. Валидировать JSON (базовая схема)
3. Проверить дедупликацию (по hash)
4. Добавить в очередь для фоновой обработки
5. **Немедленно вернуть** `200 OK`

```json
{
  "ok": true,
  "queued": true,
  "syncMs": 45
}
```

#### 4. Дедупликация событий

**Проблема:** RentProg может отправлять одно событие несколько раз.

**Решение:**
- Генерировать hash события (SHA256 от payload + timestamp)
- Хранить hash в Redis или in-memory LRU cache
- TTL дедупликации: **15 минут**

**Алгоритм:**
```
hash = SHA256(JSON.stringify(payload) + timestamp)
if (exists_in_cache(hash)):
    return { ok: true, duplicate: true }
else:
    set_cache(hash, TTL=15m)
    queue_for_processing()
    return { ok: true, queued: true }
```

### Форматы вебхуков

RentProg отправляет события в разных форматах:

#### JSON формат (новый)

```json
{
  "event": "booking_update",
  "payload": "{\"id\":470049,\"state\":[\"Новая\",\"Активная\"],\"created_from_api\":true}"
}
```

#### Ruby-style формат (старый)

```json
{
  "event": "booking_update",
  "payload": "{\"state\"=>[\"Новая\", \"Активная\"], \"id\"=>470049}"
}
```

**Важно:** Парсите оба формата. Ruby-style нужно конвертировать:

```
"=>" → ":"
добавить кавычки к ключам
затем JSON.parse()
```

### Типы событий

#### booking_update

Обновление бронирования.

**Payload:**
```json
{
  "id": 470049,
  "state": ["Новая", "Активная"],  // [старое_значение, новое_значение]
  "created_from_api": true,
  "updated_from_api": false,
  "user_id": 123
}
```

#### booking_create

Создание нового бронирования.

**Payload:**
```json
{
  "id": 471135,
  "created_from_api": true,
  "active": true,
  "state": "Новая",
  "start_date": "25-01-2022 10:00",
  "end_date": "28-01-2022 10:00",
  "total": 15000,
  "deposit": 5000
}
```

#### car_update

Обновление автомобиля.

**Payload:**
```json
{
  "id": 45373,
  "clean_state": [true, false],  // [старое, новое]
  "mileage": [211361, 212359],   // [старое, новое]
  "created_from_api": false,
  "updated_from_api": true
}
```

#### client_update

Обновление клиента.

**Payload:**
```json
{
  "id": 352754,
  "category": ["Новый", "Постоянный"],  // [старое, новое]
  "created_from_api": false,
  "updated_from_api": true
}
```

#### client_create

Создание нового клиента.

**Payload:**
```json
{
  "id": 123,
  "name": "Иван Иванов",
  "email": "ivan@example.com",
  "phone": "+79001234567"
}
```

### Парсинг вебхуков

**Алгоритм определения сущности и действия:**

1. **Определение типа события:**
   - Проверить `event`, `type`, `name` (регистронезависимо)
   - Поддержка русских и английских названий

2. **Определение сущности (entity):**
   - Из `entity`, `object`
   - По ключевым словам: `бронир|booking|reserv` → `booking`, `автомоб|car|vehicle` → `car`, `клиент|client|customer` → `client`
   - Из payload: `booking_id` → `booking`, `car_id` → `car`, `client_id` → `client`

3. **Определение действия (action):**
   - Из `action`, `status`
   - По ключевым словам: `создан|create` → `created`, `обнов|update` → `updated`, `удален|delete` → `deleted`

4. **Определение ID:**
   - Из `id`, `entity_id`, `object_id`
   - Из payload: `id`, `booking_id`, `car_id`, `client_id`

5. **Определение филиала (branch):**
   - Из `branch`, `branch_name`, `office`, `department`
   - Из payload: `branch`, `branch_name`, `branch_id`
   - **Важно:** Для клиентов (`client`) branch может отсутствовать (клиенты глобальные)

### Обработка вебхуков

**Поток обработки:**

```
1. Получение вебхука
   ↓
2. Rate Limit проверка
   ↓
3. JSON Size проверка
   ↓
4. Валидация схемы (Zod/JSON Schema)
   ↓
5. Генерация hash события
   ↓
6. Дедупликация
   ↓
7. Парсинг (entity, action, id, payload, branch)
   ↓
8. Быстрый ACK (200 OK)
   ↓
9. Добавление в очередь для фоновой обработки
   ↓
10. Фоновая обработка:
    - Сохранение события в БД
    - Попытка получить полные данные через API
    - Upsert в локальную БД
    - Создание фоновых задач при неудаче
```

### Автоматическое дотягивание данных (Auto-Fetch)

**Проблема:** Вебхуки содержат минимальные данные.

**Решение:** При получении вебхука о создании/обновлении:

1. **Мгновенная попытка** получить полные данные через API
2. **При успехе:** сохранить с меткой `details_fetched_at`
3. **При неудаче:**
   - Сохранить "сырые" данные из вебхука
   - Создать фоновую задачу `rentprog_fetch_full`

**Фоновая обработка:**
- Перебирать филиалы до получения данных
- Сохранять полные данные при успехе
- Логировать ошибки для мониторинга

**Мониторинг:**
- Метрика `fetch_full_total{entity, result}` — счётчики попыток
- Результаты: `ok`, `miss`, `skipped`, `rate_limited`

---

## Форматы данных

### Автомобили

#### Основные поля

```json
{
  "id": 45373,
  "car_name": "Toyota Camry",
  "code": "CAMRY-01",
  "number": "А123БВ77",
  "vin": "JT2BF28KX00123456",
  "body_number": "BODY123",
  "pts": "77МП123456",
  "registration_certificate": "РЕГ123456",
  "year": 2020,
  "color": "Белый",
  "transmission": "Автоматическая",
  "is_air": true,
  "engine_capacity": "2.5",
  "is_electropackage": true,
  "car_class": "Комфорт",
  "car_type": "Седан",
  "fuel": "Бензин",
  "number_doors": 4,
  "state": 0,
  "mileage": 50000
}
```

#### Оборудование (boolean поля)

- `heated_seats` — подогрев сидений
- `heated_seats_front` — подогрев передних сидений
- `parktronic` — парктроник
- `parktronic_back` — парктроник задний
- `parktronic_camera` — камера заднего вида
- `wheel_adjustment` — регулировка руля
- `wheel_adjustment_full` — полная регулировка руля
- `audio_system` — аудиосистема
- `video_system` — видеосистема
- `tv_system` — ТВ система
- `cd_system` — CD система
- `usb_system` — USB система
- `climate_control` — климат-контроль
- `folding_seats` — складывающиеся сиденья
- `heated_windshield` — подогрев лобового стекла
- `rain_sensor` — датчик дождя

#### Кастомные поля

- `custom_field_1`, `custom_field_2`, `custom_field_3` — произвольные строковые поля

#### Изображения

Поля для URL изображений (варьируются):
- `image_url`
- `photo_url`
- `photo`
- `avatar_url`

#### Состояния

- `state` — числовое состояние (0 = активен, другие значения зависят от системы)
- `is_deleted` / `deleted` — флаг удаления
- `clean_state` — состояние чистоты (true/false)

### Бронирования

#### Основные поля

```json
{
  "id": 470049,
  "active": true,
  "state": "Активная",
  "start_date": "25-01-2022 10:00",
  "end_date": "28-01-2022 10:00",
  "days": 3,
  "additional_hours": 0,
  "price": 15000,
  "rental_cost": 12000,
  "hours_cost": 0,
  "delivery": 500,
  "delivery_end": 0,
  "chair": true,
  "booster": true,
  "chairs_quantity": 1,
  "boosters_quantity": 0,
  "equipment": 500,
  "total": 15500,
  "deposit": 5000,
  "car_id": 45373,
  "client_id": 352754
}
```

#### Состояния бронирования

**Возможные значения `state`:**
- `"Новая"` — только создана
- `"Активная"` — в процессе
- `"Завершена"` — завершена
- `"Отменена"` — отменена
- Другие значения зависят от настроек системы

**Флаги:**
- `active` — активно ли бронирование (boolean)
- `created_from_api` — создано через API
- `updated_from_api` — обновлено через API

#### Даты

**Формат:** `DD-MM-YYYY H:mm` (например: `25-01-2022 10:00`)

**Важно:** 
- Конвертировать в ISO 8601 для хранения
- Учитывать часовой пояс (RentProg может использовать локальное время)

#### Цены и расчёты

- `price` — базовая цена
- `rental_cost` — стоимость аренды
- `hours_cost` — стоимость дополнительных часов
- `delivery` — стоимость доставки
- `delivery_end` — стоимость возврата
- `equipment` — стоимость дополнительного оборудования
- `total` — итоговая сумма
- `deposit` — депозит

#### Дополнительное оборудование

- `chair` — детское кресло (boolean)
- `booster` — бустер (boolean)
- `chairs_quantity` — количество кресел
- `boosters_quantity` — количество бустеров

### Клиенты

#### Основные поля

```json
{
  "id": 352754,
  "name": "Иван Иванов",
  "email": "ivan@example.com",
  "phone": "+79001234567",
  "category": "Постоянный",
  "created_at": "2022-01-15T10:00:00Z",
  "updated_at": "2022-01-20T15:30:00Z"
}
```

#### Категории клиентов

**Возможные значения `category`:**
- `"Новый"` — новый клиент
- `"Постоянный"` — постоянный клиент
- Другие категории зависят от настроек системы

#### Контакты

- `phone` — телефон (может быть в разных форматах)
- `email` — электронная почта

---

## Обработка ошибок

### HTTP коды ошибок

- **401** — Неверный токен аутентификации
  - Действие: Обновить request token и повторить запрос
  
- **404** — Ресурс не найден
  - Действие: Проверить ID, попробовать альтернативный endpoint (fallback)
  
- **422** — Некорректные данные
  - Действие: Проверить формат входных данных
  
- **429** — Rate Limit превышен
  - Действие: Остановить запросы, подождать согласно Retry-After
  
- **500** — Внутренняя ошибка сервера RentProg
  - Действие: Повторить с экспоненциальным backoff (до 3 попыток)

### Обработка сетевых ошибок

**Типы ошибок:**
- Таймаут запроса
- Сетевая ошибка (ECONNREFUSED, ENOTFOUND)
- AbortError

**Стратегия:**
1. Повторять до `RETRY_MAX_ATTEMPTS` (по умолчанию 3)
2. Использовать экспоненциальный backoff
3. Логировать все ошибки для анализа
4. Не повторять бесконечно — установить максимальный лимит

### Обработка ошибок вебхуков

**Типы ошибок:**
1. **Невалидный JSON** — возвращать `400 Bad Request`
2. **Превышение размера** — возвращать `413 Payload Too Large`
3. **Rate Limit** — возвращать `429 Too Many Requests`
4. **Ошибка парсинга** — логировать и возвращать `200 OK` (чтобы RentProg не повторял)

**Dead Letter Queue:**
- Сохранять неуспешно обработанные события в отдельную таблицу
- Возможность повторной обработки (replay)
- Автоматическая очистка старых записей (retention 30 дней)

---

## Лучшие практики

### 1. Многфилиальность

**Проблема:** RentProg поддерживает несколько филиалов, каждый со своим токеном.

**Решение:**
- Хранить токены в формате: `branch_name:token` или JSON `{"branch1":"token1", "branch2":"token2"}`
- При запросе данных по ID — перебирать все филиалы до успеха
- Клиенты (`client`) могут быть глобальными (без привязки к филиалу)

### 2. Пагинация

**Проблема:** API возвращает ограниченное количество записей на страницу (обычно ~10-50).

**Решение:**
- Использовать параметры `page` и `limit`
- Реализовать функцию `listAll()` для автоматического сбора всех страниц
- Установить максимум страниц (например, 1000) для защиты от бесконечных циклов

**Конфигурация:**
- `RENTPROG_PAGE_PARAM` — имя параметра page (по умолчанию: `page`)
- `RENTPROG_LIMIT_PARAM` — имя параметра limit (по умолчанию: `limit`)
- `RENTPROG_DEFAULT_PAGE_SIZE` — размер страницы (по умолчанию: `10`)
- `RENTPROG_DEFAULT_MAX_PAGES` — максимум страниц (по умолчанию: `1000`)

### 3. Fallback endpoints

**Проблема:** RentProg использует разные варианты endpoints.

**Решение:** Реализовать fallback цепочки:

- `/cars/{id}` → `/car/{id}` (если 404)
- `/clients/{id}` → `/client/{id}` (если 404)
- `/bookings/{id}` → `/booking/{id}` → `/booking?id={id}` → `/search_bookings?query={id}` (если 404)

### 4. Idempotency (Идемпотентность)

**Проблема:** Одни и те же данные могут приходить несколько раз.

**Решение:**
- Использовать upsert вместо insert
- Проверять `updated_at` — обновлять только если новые данные новее
- Дедупликация вебхуков по hash
- Идемпотентные ключи для фоновых задач

### 5. Мониторинг

**Метрики для отслеживания:**

- Счётчики запросов по типам (read/write/search/auth)
- Счётчики ошибок по кодам (401, 404, 429, 500)
- Latency запросов (p50, p95, p99)
- Rate limit события
- Дедупликация вебхуков
- Фоновые задачи (backlog, успешные, неудачные)

**Selftest endpoint:**

```
GET /webhooks/_selftest
```

**Возвращает:**
- Статус дедупликации (Redis/Memory)
- Очередь (inflight, backlog)
- Метрики за последнюю минуту
- Статус Redis подключения

### 6. Безопасность

- **Не логировать токены** в открытом виде
- **Использовать HTTPS** для всех запросов
- **Валидировать вебхуки** (если RentProg поддерживает подпись)
- **Rate limiting** для защиты от перегрузки
- **Ограничение размера JSON** для защиты от DoS

### 7. Производительность

- **Кэширование токенов** (экономия 100-400 мс на запрос)
- **Параллельные запросы** где возможно (но соблюдать rate limits)
- **Батчинг** при массовой обработке
- **Фоновая обработка** вебхуков (не блокировать ответ)

### 8. Обработка изменений формата

**Проблема:** RentProg может менять формат данных без предупреждения.

**Решение:**
- Гибкий парсер с поддержкой разных форматов
- Логирование неизвестных форматов для анализа
- Fallback на базовые поля (id, entity, action)
- Версионирование парсера для отслеживания изменений

---

## Переменные окружения (Сводка)

### Базовые настройки

```bash
# Base URL
RENTPROG_BASE_URL=https://rentprog.net/api/v1/public

# Токены филиалов (формат: branch1:token1,branch2:token2)
RENTPROG_TOKENS=moscow:token1,spb:token2

# Или JSON формат
RENTPROG_TOKENS_JSON={"moscow":"token1","spb":"token2"}
```

### Аутентификация

```bash
RENTPROG_AUTH_URL=/get_token
RENTPROG_AUTH_METHOD=GET
RENTPROG_AUTH_STYLE=query
RENTPROG_AUTH_HEADER=Authorization
RENTPROG_AUTH_BODY_KEY=company_token
RENTPROG_REQUEST_TOKEN_TTL_SEC=240
```

### Пагинация

```bash
RENTPROG_PAGE_PARAM=page
RENTPROG_LIMIT_PARAM=limit
RENTPROG_DEFAULT_PAGE_SIZE=10
RENTPROG_DEFAULT_MAX_PAGES=1000
```

### HTTP и Retry

```bash
RENTPROG_REQUEST_TIMEOUT_MS=15000
RENTPROG_RETRY_MAX_ATTEMPTS=3
RENTPROG_RETRY_BASE_DELAY_MS=250
RENTPROG_RETRY_JITTER_MS=100
```

### Вебхуки

```bash
WEBHOOK_JSON_LIMIT=256kb
WEBHOOK_RATE_RPS=30
WEBHOOK_ACK_SLA_MS=100
```

---

## Заключение

Этот документ содержит весь накопленный опыт работы с RentProg API и вебхуками. Используйте его как справочник при интеграции в новых проектах.

**Ключевые моменты:**
- Двухэтапная аутентификация (company token → request token)
- Rate limiting критически важен
- Вебхуки требуют быстрого ACK и дедупликации
- Поддержка разных форматов данных (JSON и Ruby-style)
- Fallback endpoints для совместимости
- Мониторинг и метрики для отладки

**Последнее обновление:** 2025-01-XX  
**Версия документа:** 1.0

